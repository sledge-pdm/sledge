// src/renderer/WebGLRenderer.ts
import { calculate_texture_memory_usage, flip_pixels_vertically } from '@sledge/wasm';
import { getBaseLayerColor, getBlendModeId, Layer } from '~/features/layer';
import { clearDirtyTiles, getBufferPointer, getDirtyTiles } from '~/features/layer/anvil/AnvilController';
import { getAnvilOf } from '~/features/layer/anvil/AnvilManager';
import { DebugLogger } from '~/features/log/service';
import { floatingMoveManager } from '~/features/selection/FloatingMoveManager';
import { layerListStore, setCanvasStore } from '~/stores/ProjectStores';
import fragmentSrc from './shaders/blend.frag.glsl';
import vertexSrc from './shaders/fullscreen.vert.glsl';

const MAX_LAYERS = 16;
const LOG_LABEL = 'WebGLRenderer';
const logger = new DebugLogger(LOG_LABEL, false);

const CHECK_ERROR = false;

function checkGLError(gl: WebGL2RenderingContext, operation: string): boolean {
  if (CHECK_ERROR) {
    const error = gl.getError();
    if (error !== gl.NO_ERROR) {
      logger.debugError(`${operation} - ${error}`);
      return false;
    }
    return true;
  } else {
    return true;
  }
}

export class WebGLRenderer {
  private gl: WebGL2RenderingContext;
  private program: WebGLProgram;
  private vao: WebGLVertexArrayObject;
  private texArray!: WebGLTexture;
  private fullscreenQuadBuffer?: WebGLBuffer; // „Éê„ÉÉ„Éï„Ç°„ÅÆÂèÇÁÖß„Çí‰øùÊåÅ
  private currentTextureDepth: number = 0; // ÁèæÂú®„ÅÆ„ÉÜ„ÇØ„Çπ„ÉÅ„É£ÈÖçÂàó„ÅÆÊ∑±Â∫¶„ÇíËøΩË∑°

  private uLayerCountLoc!: WebGLUniformLocation;
  private uOpacitiesLoc!: WebGLUniformLocation;
  private uBlendModesLoc!: WebGLUniformLocation;
  private uHasBaseLayerLoc!: WebGLUniformLocation;
  private uBaseLayerColorLoc!: WebGLUniformLocation;
  private disposed: boolean = false;

  private isChromium: boolean = false;

  private includeBaseLayer: boolean = true;

  constructor(
    private canvas: HTMLCanvasElement,
    private width: number = 0,
    private height: number = 0,
    private layers: Layer[] = []
  ) {
    const contextOptions: WebGLContextAttributes = {
      preserveDrawingBuffer: false,
      antialias: false,
      alpha: true,
      desynchronized: false,
      depth: true,
      stencil: false,
      premultipliedAlpha: true,
      failIfMajorPerformanceCaveat: false,
      powerPreference: 'high-performance',
    };

    const gl = canvas.getContext('webgl2', contextOptions);
    if (!gl) throw new Error('WebGL2 is not supported in this browser');
    this.gl = gl;

    if (import.meta.env.DEV) this.checkWebGLCapabilities(gl);

    this.isChromium = gl.getParameter(gl.VERSION).includes('Chromium');

    // --- „Ç∑„Çß„Éº„ÉÄ„Ç≥„É≥„Éë„Ç§„É´ & „Éó„É≠„Ç∞„É©„É†„É™„É≥„ÇØ ---
    const vs = this.compileShader(gl.VERTEX_SHADER, vertexSrc);
    const fs = this.compileShader(gl.FRAGMENT_SHADER, fragmentSrc);
    const prog = gl.createProgram();
    if (!prog) throw new Error('Failed to create WebGL program');
    gl.attachShader(prog, vs);
    gl.attachShader(prog, fs);
    gl.linkProgram(prog);
    if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
      const info = gl.getProgramInfoLog(prog);
      throw new Error(`Program link failed: ${info}`);
    }
    this.program = prog;

    gl.useProgram(this.program);
    // sampler2DArray „ÅØ„É¶„Éã„ÉÉ„Éà 0
    const loc = gl.getUniformLocation(this.program, 'u_texArray')!;
    gl.uniform1i(loc, 0);

    // gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

    this.texArray = gl.createTexture()!;
    gl.bindTexture(gl.TEXTURE_2D_ARRAY, this.texArray);

    checkGLError(gl, 'texture creation and binding');

    gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    checkGLError(gl, 'texture parameter setup');

    // --- „Éï„É´„Çπ„ÇØ„É™„Éº„É≥„ÇØ„ÉØ„ÉÉ„ÉâÁî® VAO ---
    this.vao = this.createFullscreenQuad();

    this.resize(width, height);

    this.uLayerCountLoc = this.gl.getUniformLocation(this.program, 'u_layerCount')!;
    this.uOpacitiesLoc = this.gl.getUniformLocation(this.program, 'u_opacities')!;
    this.uBlendModesLoc = this.gl.getUniformLocation(this.program, 'u_blendModes')!;
    this.uHasBaseLayerLoc = this.gl.getUniformLocation(this.program, 'u_hasBaseLayer')!;
    this.uBaseLayerColorLoc = this.gl.getUniformLocation(this.program, 'u_baseLayerColor')!;

    logger.debugLog('Initialized WebGLRenderer');
  }

  public setLayers(layers: Layer[]) {
    this.layers = [...layers];
  }

  public setIncludeBaseLayer(include: boolean) {
    this.includeBaseLayer = include;
  }

  public resize(width: number, height: number, checkActualBuffer: boolean = true): void {
    this.checkDisposed();
    if (width <= 0 || height <= 0) return;
    if (width === this.width && height === this.height) return;

    logger.debugLog(`Resizing canvas from ${this.width}x${this.height} to ${width}x${height}`);

    // ÂâçÂõû„ÅÆ„É°„É¢„É™‰ΩøÁî®Èáè„Çí„É≠„Ç∞Âá∫Âäõ
    if (this.currentTextureDepth > 0) {
      const oldMemory = calculate_texture_memory_usage(this.width, this.height, this.currentTextureDepth);
      logger.debugLog(`Releasing texture memory: ${(oldMemory / 1024 / 1024).toFixed(2)} MB`);
    }

    this.width = width;
    this.height = height;

    // „Ç≠„É£„É≥„Éê„Çπ„ÅÆ„Çµ„Ç§„Ç∫„ÇíË®≠ÂÆö
    this.canvas.width = width;
    this.canvas.height = height;

    // CSS„Çπ„Çø„Ç§„É´„ÇÇÊòéÁ§∫ÁöÑ„Å´Ë®≠ÂÆöÔºàÂøÖË¶Å„Å´Âøú„Åò„Å¶Ôºâ
    this.canvas.style.width = `${width}px`;
    this.canvas.style.height = `${height}px`;

    // „Éì„É•„Éº„Éù„Éº„Éà„ÇíË®≠ÂÆö
    this.gl.viewport(0, 0, width, height);

    if (checkActualBuffer) {
      // WebGL„ÅÆÊèèÁîª„Éê„ÉÉ„Éï„Ç°„Çµ„Ç§„Ç∫„ÇíÁ¢∫Ë™ç
      const actualWidth = this.gl.drawingBufferWidth;
      const actualHeight = this.gl.drawingBufferHeight;
      logger.debugLog(`üìè Canvas size set to: ${width}x${height}`);
      logger.debugLog(`üìè WebGL drawing buffer: ${actualWidth}x${actualHeight}`);

      if (actualWidth !== width || actualHeight !== height) {
        logger.debugWarn(`‚ö†Ô∏è WebGL drawing buffer size differs from requested size!`);
        logger.debugWarn(`   Requested: ${width}x${height}`);
        logger.debugWarn(`   Actual: ${actualWidth}x${actualHeight}`);

        // „Åì„ÅÆÂ†¥Âêà„ÄÅÂÆüÈöõ„ÅÆÊèèÁîª„Éê„ÉÉ„Éï„Ç°„Çµ„Ç§„Ç∫„Çí‰ΩøÁî®„Åô„Çã
        if (actualWidth > 0 && actualHeight > 0) {
          logger.debugLog(`üîß Using actual drawing buffer size: ${actualWidth}x${actualHeight}`);
          this.width = actualWidth;
          this.height = actualHeight;

          // ÈáçË¶ÅÔºö„Åô„Åπ„Å¶„ÅÆ„É¨„Ç§„É§„Éº„Éê„ÉÉ„Éï„Ç°„ÇÇWebGL„ÅÆ„Çµ„Ç§„Ç∫„Å´Âêà„Çè„Åõ„Å¶Ë™øÊï¥
          const newSize = { width: actualWidth, height: actualHeight };
          logger.debugLog(`üîß Resizing all layer buffers to match WebGL constraints: ${actualWidth}x${actualHeight}`);

          this.layers.forEach((layer) => {
            const anvil = getAnvilOf(layer.id);
            if (anvil) {
              try {
                anvil.resize(actualWidth, actualHeight); // offset „Å™„Åó resize
                logger.debugLog(`‚úÖ Resized anvil layer buffer ${layer.id} to ${actualWidth}x${actualHeight}`);
              } catch (error) {
                logger.debugError(`‚ùå Failed to resize anvil layer buffer ${layer.id}:`, error);
              }
            }
          });

          // „Ç≠„É£„É≥„Éê„Çπ„Çπ„Éà„Ç¢„ÇÇÊõ¥Êñ∞Ôºà‰ªñ„ÅÆ„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„Å®„ÅÆÊï¥ÂêàÊÄß„Çí‰øù„Å§„Åü„ÇÅÔºâ
          setCanvasStore('canvas', newSize);
          logger.debugLog(`üìù Updated canvas store to: ${actualWidth}x${actualHeight}`);

          // „É¶„Éº„Ç∂„Éº„Å´ÂàÜ„Åã„Çä„ÇÑ„Åô„ÅÑË≠¶Âëä„É°„ÉÉ„Çª„Éº„Ç∏„ÇíË°®Á§∫
          const maxTextureSize = this.gl.getParameter(this.gl.MAX_TEXTURE_SIZE);
          logger.debugWarn(`‚ö†Ô∏è ========================= IMPORTANT WARNING =========================`);
          logger.debugWarn(`‚ö†Ô∏è Canvas size has been automatically reduced due to WebGL limitations:`);
          logger.debugWarn(`‚ö†Ô∏è   Requested: ${width}x${height}`);
          logger.debugWarn(`‚ö†Ô∏è   Actual: ${actualWidth}x${actualHeight}`);
          logger.debugWarn(`‚ö†Ô∏è This limitation is caused by WebGL memory constraint:`);
          logger.debugWarn(`‚ö†Ô∏è   ‚Ä¢ Drawing buffer limited to 1/8 of MAX_TEXTURE_SIZE¬≤ (${maxTextureSize}¬≤)`);
          logger.debugWarn(`‚ö†Ô∏è   ‚Ä¢ Theoretical limit: ~5792 pixels per side`);
          logger.debugWarn(`‚ö†Ô∏è   ‚Ä¢ Actual limit: ${actualWidth} pixels (with safety margin)`);
          logger.debugWarn(`‚ö†Ô∏è   ‚Ä¢ Memory usage: ${((actualWidth * actualHeight * 4) / 1024 / 1024).toFixed(2)} MB`);
          logger.debugWarn(`‚ö†Ô∏è All layer buffers have been resized to match WebGL constraints.`);
          logger.debugWarn(`‚ö†Ô∏è ====================================================================`);
        }
      }
    }

    // // ÂÆüÈöõ„Å´‰ΩøÁî®„Åô„Çã„É¨„Ç§„É§„ÉºÊï∞„ÅÆ„ÅøÁ¢∫‰øùÔºàÊúÄÂ∞è1„É¨„Ç§„É§„ÉºÔºâ
    const activeLayers = this.layers.filter((l) => l.enabled);
    const requiredDepth = Math.max(1, Math.min(activeLayers.length, MAX_LAYERS));
    // // „ÉÜ„ÇØ„Çπ„ÉÅ„É£ÈÖçÂàó„ÅÆ„Çµ„Ç§„Ç∫„ÇíÊõ¥Êñ∞
    this.updateTextureArraySize(requiredDepth, true);
  }

  public render(onlyDirty?: boolean): void {
    this.checkDisposed();
    if (this.width === 0 || this.height === 0) return;
    const layers = this.layers.toReversed().slice(0, MAX_LAYERS);

    logger.debugLog('üé® WebGLRenderer.render() called:', {
      layerCount: layers.length,
      onlyDirty,
      dimensions: `${this.width}x${this.height}`,
    });

    const activeLayers = layers.filter((l) => l.enabled);

    logger.debugLog('üîç Active layers:', activeLayers.length);

    // „ÉÜ„ÇØ„Çπ„ÉÅ„É£ÈÖçÂàó„ÅÆ„Çµ„Ç§„Ç∫„ÇíÂãïÁöÑ„Å´Ë™øÊï¥
    const requiredDepth = Math.max(1, activeLayers.length);
    this.updateTextureArraySize(requiredDepth);

    const { gl, program } = this;
    gl.useProgram(program);

    // „ÉÜ„ÇØ„Çπ„ÉÅ„É£„É¶„Éã„ÉÉ„Éà0„Çí„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Å´„Åó„Å¶„ÉÜ„ÇØ„Çπ„ÉÅ„É£ÈÖçÂàó„Çí„Éê„Ç§„É≥„Éâ
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D_ARRAY, this.texArray);

    checkGLError(gl, 'texture binding and activation');

    logger.debugLog('üñºÔ∏è Starting texture upload for', activeLayers.length, 'layers');

    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
    activeLayers.forEach((layer, i) => {
      logger.debugLog(`üìÑ Processing layer ${i}: ${layer.id}, enabled: ${layer.enabled}`);

      const anvil = getAnvilOf(layer.id);
      const buf =
        layer.id === layerListStore.activeLayerId && floatingMoveManager.isMoving()
          ? floatingMoveManager.getPreviewBuffer()
          : getBufferPointer(layer.id);
      if (!buf) return;

      // „Éê„ÉÉ„Éï„Ç°„Çµ„Ç§„Ç∫„ÅÆÊï¥ÂêàÊÄß„Çí„ÉÅ„Çß„ÉÉ„ÇØ
      const expectedSize = this.width * this.height * 4;
      const actualSize = buf.length;

      logger.debugLog(`üìä Buffer info: length=${buf.length}, expected=${expectedSize}`);

      if (actualSize !== expectedSize) {
        logger.debugWarn(`‚ö†Ô∏è Buffer size mismatch! Layer ${layer.id}:`);
        logger.debugWarn(`   Expected: ${expectedSize} bytes (${this.width}x${this.height}x4)`);
        logger.debugWarn(`   Actual: ${actualSize} bytes`);

        // „Éê„ÉÉ„Éï„Ç°„Çµ„Ç§„Ç∫„Åã„ÇâÂÖÉ„ÅÆ„Çµ„Ç§„Ç∫„ÇíÊé®ÂÆö
        const bufferPixels = actualSize / 4;
        const bufferSide = Math.sqrt(bufferPixels);
        logger.debugWarn(`   Buffer appears to be: ${bufferSide}x${bufferSide}`);

        // „Éê„ÉÉ„Éï„Ç°„Çµ„Ç§„Ç∫„ÅåÊúüÂæÖÂÄ§„Å®Áï∞„Å™„ÇãÂ†¥Âêà„ÄÅÂÆâÂÖ®„ÅÆ„Åü„ÇÅ„Éï„É´„Ç¢„ÉÉ„Éó„Éá„Éº„Éà„Çí„Çπ„Ç≠„ÉÉ„Éó
        logger.debugError(`‚ùå Skipping layer ${i} due to buffer size mismatch`);
        return;
      }

      const dirtyTiles = getDirtyTiles(layer.id);
      if (onlyDirty && dirtyTiles.length !== 0) {
        logger.debugLog(`üîß Processing ${dirtyTiles.length} dirty tiles for layer ${i}`);
        dirtyTiles.forEach((tile) => {
          const tileSize = anvil?.getTileSize() ?? 0;
          const col = (tile as any).col;
          const row = (tile as any).row;
          const ox = col * tileSize;
          const oy = row * tileSize;
          const w = Math.min(this.width - ox, tileSize);
          const h = Math.min(this.height - oy, tileSize);

          // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: ÂÖÉ„ÅÆJavaScriptÂÆüË£Ö
          const tileByteLength = w * h * 4;
          const tileBuffer = new Uint8Array(tileByteLength);
          for (let dy = 0; dy < h; dy++) {
            const srcStart = ((oy + dy) * this.width + ox) * 4;
            const dstStart = dy * w * 4;
            tileBuffer.set(buf.subarray(srcStart, srcStart + w * 4), dstStart);
          }

          // macOS„Åß„ÅÆWebGL„Ç®„É©„Éº„Çí„ÉÅ„Çß„ÉÉ„ÇØ
          checkGLError(gl, `before texSubImage3D tile upload layer ${i}`);

          gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, ox, oy, i, w, h, 1, gl.RGBA, gl.UNSIGNED_BYTE, tileBuffer);

          if (!checkGLError(gl, `texSubImage3D tile upload layer ${i}, pos(${ox},${oy}), size(${w},${h})`)) {
            logger.debugError(
              LOG_LABEL,
              `Tile upload failed: layer=${i}, offset=(${ox},${oy}), size=(${w},${h}), buffer.length=${tileBuffer.length}`
            );
          }
        });
      } else {
        logger.debugLog(`üì§ Full upload for layer ${i}`);

        // macOS„Åß„ÅÆWebGL„Ç®„É©„Éº„Çí„ÉÅ„Çß„ÉÉ„ÇØ
        checkGLError(gl, `before full texSubImage3D upload layer ${i}`);

        // „Éï„É´„Ç¢„ÉÉ„Éó„Éá„Éº„Éà
        gl.texSubImage3D(
          gl.TEXTURE_2D_ARRAY,
          0,
          0,
          0,
          i, // x, y, layer index
          this.width,
          this.height,
          1, // depth = 1 (Ôºë„É¨„Ç§„É§„ÉºÂàÜ)
          gl.RGBA,
          gl.UNSIGNED_BYTE,
          buf
        );

        if (!checkGLError(gl, `full texSubImage3D upload layer ${i}, size(${this.width},${this.height})`)) {
          logger.debugError(`Full upload failed: layer=${i}, size=(${this.width},${this.height}), buffer.length=${buf.length}`);
        }

        // „Éï„É´„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÂæå„ÅØ dirty „Éï„É©„Ç∞„Çí„ÇØ„É™„Ç¢ (patch ÁµåÁî±„Åß„Å™„ÅÑÊõ¥Êñ∞„Ç±„Éº„Çπ)
        clearDirtyTiles(layer.id);
      }
    });

    const opacities = new Float32Array(MAX_LAYERS);
    const blendModes = new Int32Array(MAX_LAYERS);
    activeLayers.forEach((layer, i) => {
      opacities[i] = layer.opacity;
      blendModes[i] = getBlendModeId(layer.mode);
    });

    logger.debugLog('üéõÔ∏è Setting uniforms:', {
      layerCount: activeLayers.length,
      opacities: Array.from(opacities.slice(0, activeLayers.length)),
      blendModes: Array.from(blendModes.slice(0, activeLayers.length)),
    });

    checkGLError(gl, 'before setting uniforms');

    gl.uniform1i(this.uLayerCountLoc, activeLayers.length);
    checkGLError(gl, 'after setting layer count uniform');

    gl.uniform1fv(this.uOpacitiesLoc, opacities);
    checkGLError(gl, 'after setting opacities uniform');

    gl.uniform1iv(this.uBlendModesLoc, blendModes);
    checkGLError(gl, 'after setting blend modes uniform');

    if (this.includeBaseLayer) {
      // „Éô„Éº„Çπ„É¨„Ç§„É§„Éº„ÅÆË®≠ÂÆö
      const baseLayer = layerListStore.baseLayer;
      gl.uniform1i(this.uHasBaseLayerLoc, 1);

      const baseColor = getBaseLayerColor(baseLayer);
      // „Éô„Éº„Çπ„É¨„Ç§„É§„Éº„ÅÆ‰∏çÈÄèÊòéÂ∫¶„ÇÇËÄÉÊÖÆ
      const finalColor = [baseColor[0], baseColor[1], baseColor[2], baseColor[3]];
      gl.uniform4f(this.uBaseLayerColorLoc, finalColor[0], finalColor[1], finalColor[2], finalColor[3]);
      logger.debugLog('üé® Base layer color:', finalColor, 'mode:', baseLayer.colorMode);
    } else {
      // „Éô„Éº„Çπ„Çí‰Ωø„Çè„Å™„ÅÑ
      this.gl.uniform1i(this.uHasBaseLayerLoc, 0);
      // u_baseLayerColor „ÅØÊú™‰ΩøÁî®„Å†„Åå0„ÇíÂÖ•„Çå„Å¶„Åä„Åè
      this.gl.uniform4f(this.uBaseLayerColorLoc, 0, 0, 0, 0);
      logger.debugLog('üé® Base layer disabled for this render');
    }

    checkGLError(gl, 'after setting base layer uniforms');

    // „Éï„É´„Çπ„ÇØ„É™„Éº„É≥„ÇØ„ÉØ„ÉÉ„Éâ„ÇíÊèèÁîª
    logger.debugLog(`üñåÔ∏è Drawing fullscreen quad...`);

    checkGLError(gl, 'before binding VAO');
    gl.bindVertexArray(this.vao);
    checkGLError(gl, 'after binding VAO');

    checkGLError(gl, 'before drawArrays');
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    checkGLError(gl, 'after drawArrays');

    // WebGL„Ç®„É©„Éº„Çí„ÉÅ„Çß„ÉÉ„ÇØ
    const error = gl.getError();
    if (error !== gl.NO_ERROR) {
      logger.debugError('‚ùå WebGL Error:', error);
    } else {
      logger.debugLog(`‚úÖ Render completed successfully`);
    }
  }

  public isDisposed(): boolean {
    return this.disposed;
  }

  /** „Ç∑„Çß„Éº„ÉÄ„Çí„Ç≥„É≥„Éë„Ç§„É´„Åô„Çã„É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£ */
  private compileShader(type: GLenum, source: string): WebGLShader {
    const shader = this.gl.createShader(type);
    if (!shader) throw new Error('Failed to create shader');
    this.gl.shaderSource(shader, source);
    this.gl.compileShader(shader);
    if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
      const info = this.gl.getShaderInfoLog(shader);
      throw new Error(`Shader compile error: ${info}`);
    }
    return shader;
  }

  /** „Éï„É´„Çπ„ÇØ„É™„Éº„É≥„ÇØ„ÉØ„ÉÉ„ÉâÁî® VAO „Çí‰ΩúÊàê */
  private createFullscreenQuad(): WebGLVertexArrayObject {
    const { gl, program } = this;
    const vao = gl.createVertexArray();
    if (!vao) throw new Error('Failed to create VAO');
    gl.bindVertexArray(vao);

    let vertices: Float32Array;
    if (this.isChromium) {
      // ChromiumÁ≥ª„Éñ„É©„Ç¶„Ç∂„Åß„ÅØÊúÄÈÅ©Âåñ„Åï„Çå„Åü„Éï„É´„Çπ„ÇØ„É™„Éº„É≥„ÇØ„ÉØ„ÉÉ„Éâ„Çí‰ΩøÁî®
      vertices = new Float32Array([-1, -1, 3, -1, -1, 3]);
    } else {
      vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1]);
    }

    const buf = gl.createBuffer();
    if (!buf) throw new Error('Failed to create buffer');

    // „Éê„ÉÉ„Éï„Ç°„ÅÆÂèÇÁÖß„Çí‰øùÊåÅ„Åó„Å¶dispose„ÅßÂâäÈô§„Åß„Åç„Çã„Çà„ÅÜ„Å´„Åô„Çã
    this.fullscreenQuadBuffer = buf;

    gl.bindBuffer(gl.ARRAY_BUFFER, buf);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

    const posLoc = gl.getAttribLocation(program, 'a_pos');
    if (posLoc >= 0) {
      gl.enableVertexAttribArray(posLoc);
      gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
    } else {
      logger.debugWarn('Attribute a_pos not found in shader program');
    }

    checkGLError(gl, 'fullscreen quad VAO setup');

    gl.bindVertexArray(null);
    return vao;
  }

  readPixelsAsBuffer(): Uint8ClampedArray {
    const gl = this.gl;

    logger.debugLog(`üìñ Reading pixels as buffer: ${this.width}x${this.height}`);

    this.render(false); // „Éï„É´„Ç¢„ÉÉ„Éó„Éá„Éº„Éà

    // „Éì„É•„Éº„Éù„Éº„Éà„Çµ„Ç§„Ç∫„ÇíÁ¢∫Ë™ç
    const viewport = gl.getParameter(gl.VIEWPORT);
    logger.debugLog(`üìè Current viewport: [${viewport[0]}, ${viewport[1]}, ${viewport[2]}, ${viewport[3]}]`);

    // „Éï„É¨„Éº„É†„Éê„ÉÉ„Éï„Ç°„ÅÆ„Çµ„Ç§„Ç∫„ÇíÁ¢∫Ë™ç
    const drawingBufferWidth = gl.drawingBufferWidth;
    const drawingBufferHeight = gl.drawingBufferHeight;
    logger.debugLog(`üñºÔ∏è Drawing buffer size: ${drawingBufferWidth}x${drawingBufferHeight}`);

    if (drawingBufferWidth !== this.width || drawingBufferHeight !== this.height) {
      logger.debugWarn(
        LOG_LABEL,
        `‚ö†Ô∏è Drawing buffer size mismatch! Expected: ${this.width}x${this.height}, Actual: ${drawingBufferWidth}x${drawingBufferHeight}`
      );
    }

    // ‚ë† WebGL „ÅÆÊèèÁîª„Éê„ÉÉ„Éï„Ç°„ÅåÁèæÂú®„ÅÆÊèèÁîªÁµêÊûú„Çí‰øùÊåÅ„Åó„Å¶„ÅÑ„ÇãÂâçÊèê„Åß„ÄÅ
    //    gl.readPixels() „Åß„Åô„Åê„Å´„Éî„ÇØ„Çª„É´„Éá„Éº„Çø„ÇíÂèñÂæó„Åô„Çã„ÄÇ
    //    Ôºà‚Äª„Åü„Å®„Åà„Å∞ export „Éú„Çø„É≥„ÇíÊäº„Åó„ÅüÁõ¥Âæå„Å´Âëº„Åπ„Å∞„ÄÅÊ¨°„ÅÆ„ÇØ„É™„Ç¢Ââç„ÅÆÁä∂ÊÖã„ÇíÂèñ„Çå„ÇãÔºâ
    const pixels = new Uint8Array(this.width * this.height * 4);

    try {
      gl.readPixels(
        0, // x
        0, // y
        this.width,
        this.height,
        gl.RGBA, // „Éï„Ç©„Éº„Éû„ÉÉ„Éà
        gl.UNSIGNED_BYTE,
        pixels // Ë™≠„ÅøÂèñ„ÇäÂÖà„Éê„ÉÉ„Éï„Ç°
      );

      const error = gl.getError();
      if (error !== gl.NO_ERROR) {
        logger.debugError(`‚ùå readPixels failed with error: ${error} (0x${error.toString(16)})`);
      } else {
        logger.debugLog(`‚úÖ readPixels successful: ${pixels.length} bytes read`);
      }
    } catch (e) {
      logger.debugError('‚ùå Exception during readPixels:', e);
    }

    return new Uint8ClampedArray(pixels.buffer);
  }

  public readPixelsFlipped(): Uint8ClampedArray {
    const gl = this.gl;
    const w = this.width;
    const h = this.height;

    // (1) „Éï„É´„Ç¢„ÉÉ„Éó„Éá„Éº„Éà ‚Üí „Éî„ÇØ„Çª„É´Ë™≠„ÅøÂèñ„Çä
    this.render(false);
    this.gl.finish?.();
    const raw = new Uint8Array(w * h * 4);
    gl.readPixels(0, 0, w, h, gl.RGBA, gl.UNSIGNED_BYTE, raw);

    // (2) WASMÈñ¢Êï∞„Çí‰Ωø„Å£„ÅüÈ´òÈÄü„Å™‰∏ä‰∏ãÂèçËª¢
    const flipped = new Uint8Array(raw);
    flip_pixels_vertically(flipped, w, h);

    return new Uint8ClampedArray(flipped.buffer);
  }

  /**
   * ÁèæÂú®„ÅÆ„Éï„É¨„Éº„É†„Éê„ÉÉ„Éï„Ç°„Çí„Åù„ÅÆ„Åæ„ÅæË™≠„ÅøÂá∫„ÅôÔºà‰∏ä‰∏ãÂèçËª¢„Å™„Åó„ÄÅÂÜç„É¨„É≥„ÉÄ„É™„É≥„Ç∞„Å™„ÅóÔºâ
   */
  public readPixelsRaw(): Uint8ClampedArray {
    this.checkDisposed();
    const gl = this.gl;
    const w = this.width;
    const h = this.height;

    const raw = new Uint8Array(w * h * 4);
    gl.readPixels(0, 0, w, h, gl.RGBA, gl.UNSIGNED_BYTE, raw);
    return new Uint8ClampedArray(raw.buffer);
  }

  /**
   * WebGL„É™„ÇΩ„Éº„Çπ„ÇíÈÅ©Âàá„Å´ÈñãÊîæ„Åô„Çã
   */
  public dispose(): void {
    if (this.disposed) return;

    const gl = this.gl;

    // „ÉÜ„ÇØ„Çπ„ÉÅ„É£„ÇíÂâäÈô§
    if (this.texArray) {
      gl.deleteTexture(this.texArray);
      logger.debugLog('WebGL texture array disposed');
    }

    // „Éó„É≠„Ç∞„É©„É†„ÇíÂâäÈô§
    if (this.program) {
      gl.deleteProgram(this.program);
      logger.debugLog('WebGL program disposed');
    }

    // VAO„ÇíÂâäÈô§
    if (this.vao) {
      gl.deleteVertexArray(this.vao);
      logger.debugLog('WebGL VAO disposed');
    }

    // „Éê„ÉÉ„Éï„Ç°„ÇíÂâäÈô§
    if (this.fullscreenQuadBuffer) {
      gl.deleteBuffer(this.fullscreenQuadBuffer);
      logger.debugLog('WebGL buffer disposed');
    }

    this.disposed = true;
    logger.debugLog('WebGL renderer disposed completely');
  }

  /**
   * dispose„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ„Åó„ÄÅdispose„Åï„Çå„Å¶„ÅÑ„Åü„Çâ‰æãÂ§ñ„ÇíÊäï„Åí„Çã
   */
  private checkDisposed(): void {
    if (this.disposed) {
      throw new Error('WebGLRenderer has been disposed');
    }
  }

  /**
   * „ÉÜ„ÇØ„Çπ„ÉÅ„É£ÈÖçÂàó„ÅÆ„Çµ„Ç§„Ç∫„ÇíÂãïÁöÑ„Å´Ë™øÊï¥„Åô„Çã
   */
  private updateTextureArraySize(requiredDepth: number, force?: boolean): void {
    if (requiredDepth === this.currentTextureDepth && !force) return;
    let oldDepth = this.currentTextureDepth;
    this.currentTextureDepth = requiredDepth;

    const gl = this.gl;
    gl.bindTexture(gl.TEXTURE_2D_ARRAY, this.texArray);

    logger.debugLog(`üîÑ Updating texture array: ${this.width}x${this.height}x${requiredDepth} (was ${oldDepth})`);

    checkGLError(gl, `before texImage3D resize to depth ${requiredDepth}`);

    // „Çà„ÇäË©≥Á¥∞„Å™„Ç®„É©„Éº„ÉÅ„Çß„ÉÉ„ÇØ„ÇíËøΩÂä†
    const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
    const maxTextureLayers = gl.getParameter(gl.MAX_ARRAY_TEXTURE_LAYERS);

    if (this.width > maxTextureSize || this.height > maxTextureSize) {
      logger.debugError(`‚ùå Texture size (${this.width}x${this.height}) exceeds MAX_TEXTURE_SIZE (${maxTextureSize})`);
    }

    if (requiredDepth > maxTextureLayers) {
      logger.debugError(`‚ùå Required depth (${requiredDepth}) exceeds MAX_ARRAY_TEXTURE_LAYERS (${maxTextureLayers})`);
    }

    try {
      gl.texImage3D(
        gl.TEXTURE_2D_ARRAY,
        0, // level
        gl.RGBA8, // ÂÜÖÈÉ®„Éï„Ç©„Éº„Éû„ÉÉ„ÉàÔºàWebGL2Ôºâ
        this.width,
        this.height,
        this.currentTextureDepth, // Êñ∞„Åó„ÅÑ„É¨„Ç§„É§„ÉºÊï∞
        0, // border (must be 0)
        gl.RGBA,
        gl.UNSIGNED_BYTE,
        null
      );

      const error = gl.getError();
      if (error === gl.NO_ERROR) {
        logger.debugLog(`‚úÖ Texture array resize successful: ${this.width}x${this.height}x${requiredDepth}`);
      } else {
        logger.debugError(`‚ùå Texture array resize failed with WebGL error: ${error} (0x${error.toString(16)})`);

        // „Ç®„É©„Éº„ÅÆË©≥Á¥∞ÂàÜÊûê
        switch (error) {
          case gl.INVALID_VALUE:
            logger.debugError('  ‚Üí INVALID_VALUE: One or more parameters are invalid');
            logger.debugError(`    Width: ${this.width}, Height: ${this.height}, Depth: ${this.currentTextureDepth}`);
            break;
          case gl.INVALID_OPERATION:
            logger.debugError('  ‚Üí INVALID_OPERATION: Operation not allowed in current state');
            break;
          case gl.OUT_OF_MEMORY:
            logger.debugError('  ‚Üí OUT_OF_MEMORY: Insufficient memory for texture');
            const estimatedMemory = (this.width * this.height * 4 * this.currentTextureDepth) / 1024 / 1024;
            logger.debugError(`    Estimated memory needed: ${estimatedMemory.toFixed(2)} MB`);
            break;
        }
      }
    } catch (e) {
      logger.debugError('‚ùå Exception during texture array resize:', e);
    }

    if (!checkGLError(gl, `texImage3D resize to depth ${requiredDepth}, size(${this.width},${this.height})`)) {
      logger.debugError(`Texture array resize failed: depth=${requiredDepth}, size=(${this.width},${this.height})`);
    }

    // WASMÈñ¢Êï∞„Çí‰Ωø„Å£„Åü„É°„É¢„É™‰ΩøÁî®ÈáèË®àÁÆó
    const oldMemory = calculate_texture_memory_usage(this.width, this.height, oldDepth);
    const newMemory = calculate_texture_memory_usage(this.width, this.height, requiredDepth);

    logger.debugLog(`üîÑ Resizing texture array from ${oldDepth} to ${requiredDepth} layers`);
    logger.debugLog(`üìä Memory change: ${(oldMemory / 1024 / 1024).toFixed(2)} MB ‚Üí ${(newMemory / 1024 / 1024).toFixed(2)} MB`);
  }

  private checkWebGLCapabilities(gl: WebGL2RenderingContext): void {
    logger.debugLog('üîç WebGL2 Capabilities Check:');
    logger.debugLog('Vendor:', gl.getParameter(gl.VENDOR));
    logger.debugLog('Renderer:', gl.getParameter(gl.RENDERER));
    logger.debugLog('Version:', gl.getParameter(gl.VERSION));
    logger.debugLog('GLSL Version:', gl.getParameter(gl.SHADING_LANGUAGE_VERSION));

    // „ÉÜ„ÇØ„Çπ„ÉÅ„É£ÈÖçÂàó„ÅÆÂà∂Èôê„Çí„ÉÅ„Çß„ÉÉ„ÇØ
    const maxTextureLayers = gl.getParameter(gl.MAX_ARRAY_TEXTURE_LAYERS);
    const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
    const max3DTextureSize = gl.getParameter(gl.MAX_3D_TEXTURE_SIZE);
    const maxRenderbufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
    const maxViewportDims = gl.getParameter(gl.MAX_VIEWPORT_DIMS);

    logger.debugLog('Max Array Texture Layers:', maxTextureLayers);
    logger.debugLog('Max Texture Size:', maxTextureSize);
    logger.debugLog('Max 3D Texture Size:', max3DTextureSize);
    logger.debugLog('Max Renderbuffer Size:', maxRenderbufferSize);
    logger.debugLog('Max Viewport Dimensions:', maxViewportDims);

    // „ÉÜ„ÇØ„Çπ„ÉÅ„É£„É°„É¢„É™„ÅÆÊé®ÂÆö„ÉÅ„Çß„ÉÉ„ÇØ
    const memoryEstimate = (this.width * this.height * 4 * MAX_LAYERS) / 1024 / 1024;
    logger.debugLog(`Estimated texture memory usage: ${memoryEstimate.toFixed(2)} MB`);

    if (maxTextureLayers < MAX_LAYERS) {
      logger.debugWarn(`‚ö†Ô∏è System supports only ${maxTextureLayers} texture layers, but we need ${MAX_LAYERS}`);
    }

    // Â§ß„Åç„Å™„Ç≠„É£„É≥„Éê„Çπ„Çµ„Ç§„Ç∫„ÅÆË≠¶Âëä
    if (this.width > maxTextureSize || this.height > maxTextureSize) {
      logger.debugError(`‚ùå Canvas size (${this.width}x${this.height}) exceeds WebGL MAX_TEXTURE_SIZE (${maxTextureSize})`);
    } else if (this.width > maxTextureSize * 0.8 || this.height > maxTextureSize * 0.8) {
      logger.debugWarn(`‚ö†Ô∏è Canvas size (${this.width}x${this.height}) is approaching WebGL MAX_TEXTURE_SIZE (${maxTextureSize})`);
    }

    // ÁèæÂú®„ÅÆ„Ç≠„É£„É≥„Éê„Çπ„Çµ„Ç§„Ç∫„Åß„ÅÆ„ÉÜ„ÇØ„Çπ„ÉÅ„É£‰ΩúÊàê„ÉÜ„Çπ„Éà„ÇíÂÆüË°å
    this.testTextureCreation(gl, this.width, this.height);
  }

  public getMaxTextureSize(): number {
    return this.gl.getParameter(this.gl.MAX_TEXTURE_SIZE);
  }

  /**
   * ÊåáÂÆö„Åï„Çå„Åü„Çµ„Ç§„Ç∫„Åß„ÉÜ„ÇØ„Çπ„ÉÅ„É£„ÅÆ‰ΩúÊàê„ÅåÂèØËÉΩ„Åã„ÉÜ„Çπ„Éà„Åô„Çã
   */
  private testTextureCreation(gl: WebGL2RenderingContext, width: number, height: number): void {
    if (width === 0 || height === 0) return;

    logger.debugLog(`üß™ Testing texture creation for size: ${width}x${height}`);

    // WebGL„ÅÆÂà∂ÈôêÂÄ§„ÇíË©≥Á¥∞„Å´Ë™øÊüª
    const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
    const maxRenderbufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
    const maxViewportDims = gl.getParameter(gl.MAX_VIEWPORT_DIMS);
    const maxTextureImageUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    const maxFragmentUniformVectors = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
    const maxVertexUniformVectors = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);

    logger.debugLog(`üîç Detailed WebGL limits analysis:`);
    logger.debugLog(`   MAX_TEXTURE_SIZE: ${maxTextureSize}`);
    logger.debugLog(`   MAX_RENDERBUFFER_SIZE: ${maxRenderbufferSize}`);
    logger.debugLog(`   MAX_VIEWPORT_DIMS: [${maxViewportDims[0]}, ${maxViewportDims[1]}]`);
    logger.debugLog(`   MAX_TEXTURE_IMAGE_UNITS: ${maxTextureImageUnits}`);
    logger.debugLog(`   MAX_FRAGMENT_UNIFORM_VECTORS: ${maxFragmentUniformVectors}`);
    logger.debugLog(`   MAX_VERTEX_UNIFORM_VECTORS: ${maxVertexUniformVectors}`);

    // „É°„É¢„É™Èñ¢ÈÄ£„ÅÆÊé®ÂÆö
    const estimatedMemory = (width * height * 4) / 1024 / 1024;
    logger.debugLog(`üíæ Estimated memory for ${width}x${height} RGBA texture: ${estimatedMemory.toFixed(2)} MB`);

    // 5759„Å®„ÅÑ„ÅÜÊï∞ÂÄ§„ÅÆË¨é„ÇíËß£Êòé„Åô„Çã„Åü„ÇÅ„ÅÆË®àÁÆó
    // Áô∫Ë¶ã: 5759 ‚âà sqrt(MAX_TEXTURE_SIZE¬≤ / 8) - ÂÆâÂÖ®„Éû„Éº„Ç∏„É≥
    // MAX_TEXTURE_SIZE¬≤ / 8 = 16384¬≤ / 8 = 33,554,432 pixels
    // sqrt(33,554,432) ‚âà 5792.62 pixels per side
    // ÂÆüÈöõ„ÅÆÂà∂Èôê 5759 = ÁêÜË´ñÂÄ§ 5792 - ÂÆâÂÖ®„Éû„Éº„Ç∏„É≥ 33 pixels
    // „Åì„Çå„ÅØWebGL„ÅåÊúÄÂ§ß„ÉÜ„ÇØ„Çπ„ÉÅ„É£„É°„É¢„É™„ÅÆ1/8„ÇíÊèèÁîª„Éê„ÉÉ„Éï„Ç°„Å´Ââ≤„ÇäÂΩì„Å¶„Å¶„ÅÑ„Çã„Åü„ÇÅ
    const ratio5759 = 5759 / maxTextureSize;
    const sqrt5759 = Math.sqrt(5759);
    const pow2Near5759 = Math.pow(2, Math.floor(Math.log2(5759)));
    const theoreticalLimit = Math.sqrt((maxTextureSize * maxTextureSize) / 8);
    const safetyMargin = theoreticalLimit - 5759;

    logger.debugLog(`üîç Analysis of 5759 limit (MEMORY CONSTRAINT DISCOVERED):`);
    logger.debugLog(`   5759 / MAX_TEXTURE_SIZE(${maxTextureSize}) = ${ratio5759.toFixed(4)}`);
    logger.debugLog(`   sqrt(5759) = ${sqrt5759.toFixed(2)}`);
    logger.debugLog(`   nearest power of 2 = ${pow2Near5759}`);
    logger.debugLog(`   5759^2 = ${(5759 * 5759).toLocaleString()} pixels`);
    logger.debugLog(`   5759^2 * 4 bytes = ${((5759 * 5759 * 4) / 1024 / 1024).toFixed(2)} MB`);
    logger.debugLog(`   üîç THEORY: sqrt(MAX_TEXTURE_SIZE¬≤ / 8) = ${theoreticalLimit.toFixed(2)}`);
    logger.debugLog(`   üîç SAFETY MARGIN: ${theoreticalLimit.toFixed(2)} - 5759 = ${safetyMargin.toFixed(2)} pixels`);
    logger.debugLog(`   üîç CONCLUSION: WebGL limits drawing buffer to 1/8 of max texture memory + safety margin`);

    // „ÉÜ„Çπ„ÉàÁî®„ÅÆ‰∏ÄÊôÇÁöÑ„Å™„ÉÜ„ÇØ„Çπ„ÉÅ„É£„Çí‰ΩúÊàê
    const testTexture = gl.createTexture();
    if (!testTexture) {
      logger.debugError('‚ùå Failed to create test texture');
      return;
    }

    gl.bindTexture(gl.TEXTURE_2D_ARRAY, testTexture);

    // ÊúÄÂàù„Å´small„Å™„Çµ„Ç§„Ç∫„ÅßË©¶„Åó„Å¶„Åø„Çã
    try {
      gl.texImage3D(
        gl.TEXTURE_2D_ARRAY,
        0, // level
        gl.RGBA8,
        width,
        height,
        1, // 1„É¨„Ç§„É§„Éº„ÅßË©¶„Åô
        0, // border
        gl.RGBA,
        gl.UNSIGNED_BYTE,
        null
      );

      const error = gl.getError();
      if (error === gl.NO_ERROR) {
        logger.debugLog(`‚úÖ Test texture creation successful for ${width}x${height}`);
      } else {
        logger.debugError(`‚ùå Test texture creation failed with error: ${error} (0x${error.toString(16)})`);

        // „Ç®„É©„Éº„Ç≥„Éº„Éâ„ÅÆË©≥Á¥∞Ë™¨Êòé
        switch (error) {
          case gl.INVALID_VALUE:
            logger.debugError('  ‚Üí INVALID_VALUE: Width, height, or depth parameters are invalid');
            break;
          case gl.INVALID_OPERATION:
            logger.debugError('  ‚Üí INVALID_OPERATION: Operation is not allowed in current state');
            break;
          case gl.OUT_OF_MEMORY:
            logger.debugError('  ‚Üí OUT_OF_MEMORY: Not enough memory available');
            break;
          default:
            logger.debugError(`  ‚Üí Unknown error code: ${error}`);
        }
      }
    } catch (e) {
      logger.debugError('‚ùå Exception during test texture creation:', e);
    } finally {
      // „ÉÜ„Çπ„ÉàÁî®„ÉÜ„ÇØ„Çπ„ÉÅ„É£„ÇíÂâäÈô§
      gl.deleteTexture(testTexture);
    }
  }
}
